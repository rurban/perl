#!./perl -w
BEGIN {
    @INC = qw(lib);

    # This needs to be at BEGIN time, before any use of Config
    require './install_lib.pl';
}
use strict;

use Getopt::Long;
use File::Find;
use File::Path qw(mkpath);
use ExtUtils::Packlist;
use Pod::Man;
use vars qw(%opts $packlist);

require './Porting/pod_lib.pl';
my $state = get_pod_metadata();

$ENV{SHELL} = 'sh' if $^O eq 'os2';

my $patchlevel = substr($],3,2);
die "Patchlevel of perl ($patchlevel)",
    "and patchlevel of config.sh ($Config{'PERL_VERSION'}) don't match\n"
	if $patchlevel != $Config{'PERL_VERSION'};

my $usage =
"Usage:  installman --man1dir=/usr/wherever --man1ext=1
                   --man3dir=/usr/wherever --man3ext=3
	           --notify --verbose --silent --help
	Defaults are:
	man1dir = $Config{'installman1dir'};
	man1ext = $Config{'man1ext'};
	man3dir = $Config{'installman3dir'};
	man3ext = $Config{'man3ext'};
	--notify  (or -n) just lists commands that would be executed.
        --verbose (or -V) report all progress.
        --silent  (or -S) be silent. Only report errors.\n";

GetOptions( \%opts,
            qw( man1dir=s man1ext=s man3dir=s man3ext=s
                destdir:s notify n help silent S verbose V))
	|| die $usage;
die $usage if $opts{help};
$opts{destdir} //= '';

foreach my $pre (qw(man1 man3)) {
    $opts{"${pre}dir"} //= $opts{destdir} . $Config{"install${pre}dir"};
    $opts{"${pre}ext"} //= $Config{"${pre}ext"};
}
$opts{silent} ||= $opts{S};
$opts{notify} ||= $opts{n};
$opts{verbose} ||= $opts{V} || $opts{notify};

#Sanity checks

-x  "./perl$Config{exe_ext}"
  or warn "./perl$Config{exe_ext} not found!  Have you run make?\n";
-d  "$opts{destdir}$Config{'installprivlib'}"
	|| warn "Perl library directory $Config{'installprivlib'} not found.
		Have you run make install?.  (Installing anyway.)\n";
-x "t/perl$Config{exe_ext}"		|| warn "WARNING: You've never run 'make test'!!!",
	"  (Installing anyway.)\n";

$packlist = ExtUtils::Packlist->new("$opts{destdir}$Config{installarchlib}/.packlist");

# Install the main pod pages.
pod2man({
         map {
             ($_->[0], $_->[1])
         } @{$state->{master}}
        }, $opts{man1dir}, $opts{man1ext}, 'pod');

# Install the pods for library modules.
{
    # manpages not to be installed
    my %do_not_install = map { ($_ => 1) }
        qw(Pod/Functions.pm XS/APItest.pm XS/Typemap.pm);

    my %modpods;
    File::Find::find({no_chdir=>1,
                      wanted => sub {
                          # $_ is $File::Find::name when using no_chdir
                          if (-f $_ and /\.p(?:m|od)$/) {
                              my $pod = $_;
                              # Skip .pm files that have corresponding .pod files
                              return if $pod =~ s/\.pm$/.pod/ && -f $pod;
                              return if m!(?:^|/)t/!;
                              s!^lib/!!;
                              return if $do_not_install{$_};
                              return if is_duplicate_pod($File::Find::name);
                              $modpods{$_} = $File::Find::name;
                          }
                      }},
                     'lib');

    pod2man(\%modpods, $opts{man3dir}, $opts{man3ext}, 'lib');
}

# Install the pods embedded in the installed scripts
my $has_man1dir = $opts{man1dir} ne '' && -d $opts{man1dir};
open UTILS, "utils.lst" or die "Can't open 'utils.lst': $!";
while (<UTILS>) {
    next if /^#/;
    chomp;
    $_ = $1 if /#.*pod\s*=\s*(\S+)/;
    my ($path, $leaf) = m|^(\S*/(\S+))|;
    pod2man({$leaf, $path}, $opts{man1dir}, $opts{man1ext});
    if ($has_man1dir) {
        if (my ($link) = m|#.*link\s*=\s*\S+/(\S+)|) {
            my $old = "$opts{man1dir}/$leaf.$opts{man1ext}";
            my $new = "$opts{man1dir}/$link.$opts{man1ext}";
	    unlink($new);
	    link($old, $new);
	    my $xold = $old;
	    $xold =~ s/^\Q$opts{'destdir'}\E// if $opts{'destdir'};
	    my $xnew = $new;
	    $xnew =~ s/^\Q$opts{'destdir'}\E// if $opts{'destdir'};
	    $packlist->{$xnew} = { from => $xold, type => 'link' };
	}
    }
}

sub pod2man {
    my($modpods, $mandir, $manext, $where) = @_;
    if ($mandir eq ' ' or $mandir eq '') {
        if ($where) {
            warn "Skipping installation of $where man pages.\n"
        } else {
            warn "Skipping installation of $_ man page.\n"
                foreach values %$modpods;
        }
        return;
    }

    if ($opts{verbose}) {
        if ($where) {
            print "installing from $where\n";
        } else {
            print "installing $_\n"
                foreach sort keys %$modpods;
        }
    }

    mkpath($mandir, $opts{verbose}, 0777) unless $opts{notify};  # In File::Path

    foreach my $manpage (sort keys %$modpods) {
        my $mod = $modpods->{$manpage};

	# Skip files without pod docs
	my $has_pod;
	if (open T, $mod)
	{
	    local $_;
	    while (<T>)
	    {
                ++$has_pod and last if /^=head1\b/;
	    }

	    close T;
	}

	unless ($has_pod)
	{
	    warn "no documentation in $mod\n";
	    next;
	}

	# Convert name from  File/Basename.pm to File::Basename.3 format,
	# if necessary.
	$manpage =~ s#\.p(m|od)$##;
	if ($^O eq 'os2' || $^O eq 'amigaos' || $^O eq 'uwin' || $^O eq 'cygwin') {
	  $manpage =~ s#/#.#g;
	}
	else {
	  $manpage =~ s#/#::#g;
	}
        my $tmp = "${mandir}/${manpage}.tmp";
	$manpage = "${mandir}/${manpage}.${manext}";

        my $parser = Pod::Man->new( section => $manext,
                                    official=> 1,
                                    center  => 'Perl Programmers Reference Guide'
                                  );
	my $xmanpage = $manpage;
	$xmanpage =~ s/^\Q$opts{'destdir'}\E// if $opts{'destdir'};
        print "  $xmanpage\n";
        if (!$opts{notify} && $parser->parse_from_file($mod, $tmp)) {
            if (-s $tmp) {
                if (rename($tmp, $manpage)) {
                    $packlist->{$xmanpage} = { type => 'file' };
                    next;
                }
            }
            unlink($tmp);
	}
    }
}

$packlist->write() unless $opts{notify};
print "  Installation complete\n" if $opts{verbose};

exit 0;

sub rename {
    my($from,$to) = @_;
    if (-f $to and not unlink($to)) {
	my($i);
	for ($i = 1; $i < 50; $i++) {
	    last if CORE::rename($to, "$to.$i");
	}
	warn("Cannot rename to '$to.$i': $!"), return 0
	    if $i >= 50;	# Give up!
    }
    link($from,$to) || return 0;
    unlink($from);
}

# Local variables:
# cperl-indent-level: 4
# indent-tabs-mode: nil
# End:
#
# ex: set ts=8 sts=4 sw=4 et:
