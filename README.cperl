# -*- markdown -*-
[NOTE: To be published only when the first points are already implemented.
       i.e end of summer 2015]

cperl - a perl5 with classes, types, compilable for the business environment

Why fork perl5?
===============

The perl5 maintainers continued in the last decade to refuse to fix
critical problems, refuse to discuss critical enhancements which
extend their 2% performance improvement limit and made too many wrong
decisions which we need to overcome. it needs to get better for once,
not worse and worse.  You should not trust them when they announce
something as better, when it is in fact much worse.

The only measurable critical improvement (1.8x faster 5.22) came from
an innocent outsider and was initially heavily critized and not
understood. ("Why do we need another hash table implementation?")

We do not really care of p5p adopts all of our changes, even if would
be of course a good idea. the point is that we cannot trust them to be
able to maintain perl5 properly.

Fix breakage and bad design
---------------------------

signatures:

they came with the worst of all signature implementions which already
do exist. the slowest and with the least features, actually blocking
critical progress.

- missing support for optional types as provided for lexical variable
  declarations, in leading position as with `my int $a;` and as
  attribute, as with `($i :int :const)`

- missing syntax for return types (: or =>). for easier implementation
  we support subattributes, :<type> only,

- missing syntax and support for references, all arguments are copied
  only, as with my $arg1 = shift; but syntax for fast $_[0] access is
  nor provided.  cperl will use \$ to denote references to scalar
  lvalues.  e.g. `sub myfunc(int \$i) : int { return $i+1; }` for now
  scalar lvalue references only, `\@a` or `\%h` would be nice with
  type checks for arrayref or hashref.  maybe `\[$]` also

- wrong treatment of @_: all arguments are copied twice, first to the declared
  argument as lexical variable, and also to the old @_ array. With cperl @_ will
  only hold the &rest args, the undeclared rest.
  i.e. @_ will be empty with a slurpy ending @ or % arg.
  This is the current user-visible part of the slow-down.

- parse signatures with the parser, not an undocumented function.

- improve error reporting. in violations do not only print the
  position, also the declaration which is violated.
  e.g. `@a=();sub x(\@b){$b->[0]++} print x(\$a)`
  `Type of arg 1 to main::x must be arrayref (not a scalar ref) at -e line 1, near "\$a)"`
  =>
  `Type of arg 1 \@b to main::x must be arrayref (not a scalar ref) at -e line 1, near "\$a)"`

proper signature types are not only a great help for catching errors
early, they are performance critical, see coffescript, dart, microsoft
typescript, facebook hack.  the type inferencer will not be able to
infer many types without explicit types.  but with typed signatures,
besides the obvious solution of private methods or closed classes we
can inline most small methods, and improve most loops and array
accesses. it is also critical to implement multi methods.

undo blocked dynamic optimizations:

we unblock the possibility to perform dynamic run-time
optimizations. this is basically the same as eval "sub bla {}",
changing the definition of a function at run-time, just with an
optimized optree. We need this to perform type optimizations on
modules loaded at run-time.

undo B bootstrap breakage:

B was changed to support use strict, which broke the B::Bytecode
compiler, which added all compiler internal constants to the emitted
bytecode.  It is too bothersome in the long run to maintain our
reversion of this breakage.  It easier to check for cperl to be able
to compile to bytecode properly again.

undo constant folding de-optimization:

One particular member of p5p which was also responsible for all the
other compiler breakages, removed automatic integer optimizations
while doing constant folding, as via an implicit use integer; we
re-add this optimization.

undo support for binary symbol and package names:

by introducing unicode support for names, p5p silently allowed \0
inside names, which they called an advantage by supporting now binary
safe names.  In reality they didn't support binary names in all other
code parts which had to deal with names, and thus enabled a huge
attack vector to hide arbitrary user strings behind \0 names. we keep
the new GV API, accepting the string length, but we strip everything
behind the \0 as before 5.16.

strict names:

with use strict we do not accept unparsable symbols created from
strings.  this is a new run-time error for use strict. there's
currently no room for an explicit use strict 'names' due to a bad
strict implementation. but later when we freed 3 SV bits to hold
strict defaults we can add support for that. but using those bits for
coretypes would be more important.

TR39 confusable names:

reject confusables as described in TR39.

undo the double readonly system:

In order to support Hash unlock code, i.e. undoing readonly setting of
hash values, p5p added a second readonly bit for special values which
are not allowed to be writable. This of course pure non-sense, as the
check for this special values at Hash unlock is trivial. it does not
need to take away the last free SV bit, which we used to implement
fast coretype checks, and unlock really only needs to unlock the
previously locked values, not make all values writable, thus make
previously readonly values writable.

fix the hashes:

hashes functions need to be implemented as macros, not functions, undo
that.  provide proper abstraction, we dont need 5 times the same bad
code copied along.  use fast hash functions, not secure slow ones.
use cache-friendly open addressing, not simple, slow and DOS'able
linked lists.  seperate the keys from the values to fit the search
into a cache line.


lexical methods:

lexical methods are of course private to its enclosing class, i.e. not
visable from outside the class. and they are also closed, i.e. they
cannot be changed later. This enables the compiler to inline them
automatically when its worthwhile. e.g. when they are small enough.
They are either defined in the new style: `class .. { my method .. }`
or old style: `package .. { my sub .. }`

Since all this implementation blockage is too heavy, all the
decade-long planned features could not go forward. The blocks need to
come to an end, and the implementation needs to improve.


Plans for further core features:
--------------------------------

compile-time attribute hooks:

CHECK_SCALAR_ATTRIBUTES (for :const, :int, :num, :str) This is
basically MODIFY_*_ATTRIBUTES at compile-time with a better name to
disassociate from the run-time check of FETCH_*_ATTRIBUTES with my
lexicals.  We need to make attributes a builtin, not a compile-time
loaded .pm.

coretypes: int, num, str

provide fast ops variants for these three types to omit type checks at
run-time. with a jit only these will benefit from a jit.
also a :const attribute for all data: scalar, arrays, hash, functions, packages+classes

types:

provide a compile-time type inferencer and type checker. the
inferencer can currently only infer int on array indices and str on
hash keys, but with the help of declarations and type checks, as e.g.
in smartmatch it can infer much more.
    `if (type $a == "int") {` => $a is an int in this scope `}`
typed signatures are backwards incompatible to perl5, as this is not
yet supported upstream. the expected performance win is ~2-10x faster,
you get compile-time type warnings, a business friendly coding
environment and the possibility to display and put infered types
automatically in your code, with a cooperating editor. e.g.
    `my $n=1000;
    for (my $i=0; $i<$n; $i++) { }`
=>
    `my int $n=1000;
    for (my int $i=0; $i<$n; $i++) { }`

typed and sized arrays:

enable faster array access, uniformly typed array values, use less
memory (cache friendly), help the type system. see L<perltypes.pod>.

rewrite critical core modules in C as builtins:

builtins: strict, exporter, dynaloader, carp, attributes.
as shared lib: warnings, Config and unicode folding tables to save
memory and reduce bloat.
big constant hashes and tables need to be in a shared memory segment,
not recompiled for every fork or thread. similar to the Encode tables,
which are done properly. the risc to introduce even more performance
regressions by keeping some critical core modules as .pm is too high
and broke the compiler too often. those developers have no idea of the
impact of innocently looking additions.
we need to reduce memory, and want to reduce the size of compiled code
by 30%, but in some cases it will be 200%.

remove Attribute::Handler from core:

This evals all attributes at compile-time. Discourage its usage.

add the compiler back to core:

the testsuite runs too long for cpan users, and it needs to be
developed in sync to avoid typical 6 months wait-time after a core
change.  maybe provide python-like precompiled `ByteCache` .pmc as
default. you could pre-compile then modules with higher optimization
levels, esp. the type inferencer.
include a `Data::Compile` module to dump data to a shared library, and
possibly `Perfect::Hash` and a new ph.c to create and optimize readonly hashes.

backport core testsuite fixes for the compiler:

honor differences between compile-time und run-time, when run
compiled.  other than a few wrong testcases, the compilers does pass
the core testsuite.

... for efficient varargs passing

`...` as empty body already has a special meaning, but interestingly not
the usual meaning of varargs.  we add support for `...` as declaration
of varargs inside the signature declaration, and then `...` in a
non-empty body may be used to pass efficiently the remaining `@_` to
calls inside the body without the need to fill `@_`. as in lua.  e.g.
`sub xx (...) { yy("x", ...) }`

Longer term goals:
-----------------

proper object system:

no, not moose. rather an optimizable perl6-like object system in core.
provide a mop, i.e. metaobjects for classes, proper class and method
syntax, anonymous classes by pointer not name, proper multi dispatch
with types, roles, class and method lookup by pointer, not by name,
create native optimized shapes via mixins as in p2 (an enhanced bless),
lexical methods are private, optimize dispatch for single
inheritance. i.e the convenient class syntax extends on a single class
only, classes are finalizable by the calling application.

libffi in core:

declare extern functions and libraries and call them. There's no need
for XS and seperate compilation for most bindings. Not everybody has a
compiler, the very same compiler perl was compiled with.

editor integration:

with type inference we can provide a much nicer development
environment, which also supports the debugger. I'm thinking of a port
of ZeroBrane Studio for perl.

jit:

add a jit for the easiest platforms, and provide dynamic javascript-based
optimizations when stacks need to be replaced.
eventually even promote to bignum not double automatically,
as in perl6. but this is optional, the next points are more important.
jit's are overrated. a fast bytecode loop can easily beat a jit and optimizing
compiler, see luajit2, http://www.emulators.com/docs/nx25_nostradamus.htm or
http://nominolo.blogspot.de/2012/07/implementing-fast-interpreters.html 

optimize the vm, the runloop:

we carry around way too much bloat in the ops and the data, which is
not needed at run-time. e.g. the compiler throws away the nested
symbol table stashes if not needed, which frees 20% memory.
but think of a lua/p2-like redesign of tagged values and slimmer ops,
and eventually put the stack onto the stack.

maybe rewrite to a better register-based compiler with fixed-length 2
operands as in p2, but this might be too tricky for XS, mapping the
global stack to the local stack.  probably no SSA (three arguments),
just a cpu friendly two argument form as in p2/lua 5.1.

allow faster XS calls, user-provided function calls and method calls.
provide support for named arguments in the vm, fast not via hashes.
many of the current io+sys ops are better implemented as library
methods.  With ~50ops instead of >300 the runloop might fit into the
L1 cache again.  seperate calling of fixed arity methods from varargs.
detect and use tailcalls automatically.  do not step into a seperate
runloop for every single function call, only for coros, which do need
to record the the stack information.

run-time optimize the data, no 2x indirection to access hash and array
structs.
provide forwarding pointers to single tuples to hold all.
this could provide also the possibility for a GC if a second sweep
for timely destruction is doable.

keep native threads asis (this is not fixable), but actively help coro
support.

untangle the IO layer mess.

bring back proper `match` and `given/when`, with type support.

possibly add a clp library, a constraint logic solver, with possible
bindings to external sat solvers, like minisat, which can be included
due to its small size and license. it is solved by checking for lvalue
function calls in assignments, when the function is not declared as
:lvalue.

    use clp;
    sub fact(int $i=0) :int { assert $i>=0; return $i ? fact($i-1) : 1 }
    say fact(7);     # => 5040
    fact($_) = 5040; # solve it!
    say $_;          # => 7

Different development policies
------------------------------

p5p development and discussions are fruitless since the original
author Larry Wall left the perl5 community.  No single non-trivial
feature p5p discussed and implemented was ever successful besides
defined-or, which I count as trivial, even if the discussion about it
was enormous.  Switch, smartmatch, given/when, pseudohashes,
attributes, types, signatures, classes + mop, hash security, unicode
symbols.

with cperl we do offer technical competence.
the lead should be the most competent, not the loudest or most likeable one.
we do encourage criticism on bad design and implementation.
we develop in branches only, and only if the branch passes the test
suite on all major platforms it can be merged. we do need build servers
and performance regression tests.
we follow the perl6 development principles.
we take github pull request and do not ignore them.

How to detect cperl?
--------------------

- cperl changed modules end with `_0<num>c`, typically `_01c` (hopefully)
- config.h defines `USE_CPERL`
- Config.pm defines `usecperl`


Links:
-----

- http://www.typescriptlang.org/Content/TypeScript%20Language%20Specification.pdf  (microsoft's javascript with types)
- http://hacklang.org/ (facebook's javascript with types)
- soundscript (google's javascript with types)
- https://www.python.org/dev/peps/pep-0484/  (planned python with types)
- http://www.mypy-lang.org/ (existing python with types)
- https://news.ycombinator.com/item?id=8620129 (ruby 3.0 planned with types)
- http://crystal-lang.org/ (a good existing ruby with types)
- http://blogs.perl.org/users/rurban/2012/09/my-perl5-todo-list.html (the old plan, ignored)
- http://perl11.org/cperl
- https://github.com/perl11/cperl
- https://enterprise.cpanel.net/users/reini/repos/cperl/ (currently only in stash)
